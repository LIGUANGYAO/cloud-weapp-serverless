{
  "items": ["Java基础", "SSM相关", "设计模式"],
  "Java基础": [
    {
      "title": "List 和 Set 的区别",
      "ans": "List , Set 都是继承自 Collection 接口\nList 特点： 元素有放入顺序，元素可重复 ，\nSet 特点： 元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的 HashCode 决定的，其位置其实是固定的，加入Set 的 Object 必须定义 equals ()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）\nSet和List对比 ：\nSet：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。\nList：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变"
    },
    {
      "title": "String类为什么是不可变的？为什么是final的?",
      "ans": "什么是不可变：定义一个字符串对象，再新建一个对象赋值给这个字符串，这个赋值过程不是修改原地址的数据，而是指向一个新的对象，这就叫不可变。JDK源码里，String类被final修饰，String类有一个属性是char类型的数组，说明String类本质上是一个数组，这个数组也被final修饰，所以String类不可变。好处有：\n1. 线程安全--String对象不可变，不能被写入，所以在多线程中修改字符串的值，其他的引用指向的还是原来的对象，不会被改变。\n2. 用于实现StringPool--栈里面的多个引用可以指向StringPool里的同一个字符串，节省了很多堆空间，如果String是可变的，那StringPool就没有意义了。\n3. 便于计算哈希值-- 因为String类不可变，所以字符串很适合被hash。String类有一个hashCode()方法用于计算哈希值，在创建字符串的时候哈希值就计算出来并被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，处理速度要快过其它的键对象。\n补充：\n· String类中有个私有实例字段hash，表示该字符串的哈希值。\n· hash值的计算过程，是依据被hash的值的特征计算的，这要求被hash的值必须固定，因此被hash的值必须不可变。"
    },
    {
      "title": "HashMap的源码分析，实现原理，底层结构？",
      "ans": "HashMap是由数组+链表+红黑树组成的。数组是主体，存放的是Entry对象（Entry有四个属性：key、value、hash、next），向数组的某个位置插入一个entry对象的时候，如果发生哈希冲突，就把那个位置的entry对象作为头结点，指向要插入的entry对象，形成一个单向链表。但是链表不擅长查询，所以链表越少，HashMap的性能越好。在JDK1.8里引入了红黑树，当链表长度超过8的时候，就转换成红黑树来存储元素，提高HashMap的性能。\n实现原理：\n先用key通过哈希函数计算出一个数组索引，如果索引位置没有元素就直接放进去，如果有元素，若key相同就直接替换，若key不相同就遍历索引位置的链表，把元素插入链表。如果链表长度大于8，就转换成红黑树来存储元素。"
    },
    {
      "title": "Java GC回收在什么时候、什么东西、做什么",
      "ans": "新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。大对象以及长期存活的对象直接进入老年区。当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。"
    },
    {
      "title": "GC Roots都有哪些：",
      "ans": "虚拟机栈中的引用的对象\n方法区中静态属性引用的对象，常量引用的对象\n本地方法栈中JNI（即一般说的Native方法）引用的对象。"
    },
    {
      "title": "Synchronized与Lock",
      "ans": "Synchronized 与Lock都是可重入锁，同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁。\nSynchronized是悲观锁机制，独占锁。"
    },
    {
      "title": "String、StringBuffer、StringBuilder",
      "ans": "StringBuffer是线程安全的\nStringBuilder是非线程安全的\nString每次操作字符串，会生成一个新的对象，而StringBuffer不会"
    },
    {
      "title": "线程池的作用：",
      "ans": "在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n提高线程的可管理性。"
    }
  ],
  "SSM相关": [
    {
      "title": "Spring AOP应用场景",
      "ans": "性能检测，访问控制，日志管理，事务等。"
    },
    {
      "title": "Spring Bean的作用域：",
      "ans": "Singleton：Spring IOC容器中只有一个共享的Bean实例，一般都是Singleton作用域。\nPrototype：每一个请求，会产生一个新的Bean实例。\nRequest：每一次http请求会产生一个新的Bean实例。"
    },
    {
      "title": "SpringMVC运行原理",
      "ans": "客户端请求提交到DispatcherServlet\n由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。\nController调用业务逻辑处理后，返回ModelAndView\nDispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图\n视图负责将结果显示到客户端"
    },
    {
      "title": "Mybatis的机制",
      "ans": "每一个Mybatis的应用程序都以一个SqlSessionFactory对象的实例为核心。 首先用字节流通过Resource将配置文件读入，然后通过SqlSessionFactoryBuilder().build方法创建SqlSessionFactory， 然后再通过sqlSessionFactory.openSession()方法创建一个sqlSession为每一个数据库事务服务。 经历了Mybatis初始化 –>创建SqlSession –>运行SQL语句 返回结果三个过程"
    },
    {
      "title": "Servlet与Filter的区别",
      "ans": "Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。"
    }
  ],
  "设计模式": [
    {
      "title": "IO 流熟悉吗，用的什么设计模式？",
      "ans": "装饰器模式、适配器模式"
    },
    {
      "title": "懒汉式的单例模式如何实现单例？",
      "ans": "通过双重检测以及 synchronized,volatile 关键字实现。"
    },
    {
      "title": "Java 中有哪些代理模式？",
      "ans": "最原始的静态代理。 以及 JDK 和 Cglib 的动态代理。"
    },
    {
      "title": "说说你所熟悉或听说过的 j2ee 中的几种常用模式？",
      "ans": "IO 流的装饰器模式，Web 过滤器的责任链模式，Spring 的单例模式和工厂模式，Spring 中根据不同配置方式进行初始化的策略模式"
    },
    {
      "title": " 简述一下你了解的 Java 设计模式（总结）",
      "ans": "★单例模式：保证某个类只能有一个唯一实例，并提供一个全局的访问点。\n★简单工厂：一个工厂类根据传入的参数决定创建出那一种产品类的实例。\n工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。\n抽象工厂：创建一组相关或依赖对象族，比如创建一组配套的汉堡可乐鸡翅。\n★建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造，最后再build。\n★原型模式：通过复制现有的实例来创建新的实例，减少创建对象成本（字段需要复杂计算或者创建成本高）。\n★适配器模式：将一个类的方法接口转换成我们希望的另外一个接口。\n★组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。（无限层级的知识点树）\n★装饰模式：动态的给对象添加新的功能。\n★代理模式：为对象提供一个代理以增强对象内的方法。亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象（Integer中的少量缓存）。★外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化（比如插座和充电器，他们之间相插是固定的，但是至于插座是插在220V还是110V，充电器是充手机还是pad可以自主选择）。★模板方法模式：定义一个算法步骤，每个小步骤由子类各自实现。解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 ★策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。★状态模式：允许一个对象根据其内部状态改变而改变它的行为。★观察者模式：被观测的对象发生改变时通知它的所有观察者。备忘录模式：保存一个对象的某个状态，以便在适当的时候恢复对象。 中介者模式：许多对象利用中介者来进行交互，将网状的对象关系变.访问者模式：某种物体的使用方式是不一样的，将不同的使用方式交给访问者，而不是给这个物体。（例如对铜的使用，造币厂造硬币。雕刻厂造铜像，不应该把造硬币和造铜像的功能交给铜自己实现，这样才能解耦）\n★责任链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，\n并且沿着这条链传递请求，直到有对象处理它为止。\n迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。"
    }
  ]
}
